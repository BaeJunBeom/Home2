안드로이드 엑티비티 라이플 사이클 
1. onCreate(): 엑티비티가 생성되는 시점에 호출된다.
- 일반적으로 뷰를 생성하고 리스트에 데이터를 연결하며 이전 엑티비티 상태를 복원하는 것과 같은 초기 기동  동작을 실행한다.
2. onRestart() : 엑티비티가 정지되었다가 다시 시작할 떄 호출된다.
3. onStart() : 엑티비티가 사용자에게 보이기 시작할 떄 호출된다.
4. onResume() : 사용자와 상호 작용을 시작하는 시점에 호출된다. 이 시점에 엑티비티는 히스토리 스택의 맨 위에 위치한다.
5. onPause() : 다른 엑티비티에 의해 화면에서 가려진 시점에서 호출된다. 이전 엑비티가 onResume()을 실행하기 바로 직전에 호출된다. 
일반적으로 엑티비티의 마지막 상태를 저장하고,  CPU를 사용하는 작업을 중단한다.
6. onStop() : onPause() 다음에 호출된다. 이 단계에서 다시 엑티비티가 화면에 나타나면 onRestart()가 호출된다.
만약 시스템 메모리가 부족하게 되면 안드로이드 이 단계 엑티비티로부터 메모리를 회수하게 된다.
7.onDestory() : 엑티비티가 완전히 종료되기 전에 호출된다. 어츨리케이션은 종료되기 직전 데이터를 처리해야 하는
경우에 이 메소드를 사용한다. 종료되는 것은 사용자가 종료하는 경우도 있지만 안드로이가 
메모리 회수를 위해 엑티비티를 강제로 제거하는 경우도 있을 수 있다. 

※ new keyword 
사용자 정의 객체를 생성에는 두 단계가 필요하다.
(1) 함수를 작성하여 객체 타입을 정의한다.
(2) new연산자로 객체의 인스턴스를 생성한다. 
객체의 타입을 정의하기 위해, 객체의 이름과 속성을 명세하는 함수를 만든다.
객체는 그 자체가 또 다른 객체인 속성을 가질 수 있다. 
코드 new Foo(...)가 실행될 때 다음과 같은 일이 발생한다. 
1. Foo.prototype 을 상속하는 새로운 객체가 하나 생성된다.
2. 명시된 인자 그리고 새롭게 생성된 객체에 바인드된 this와 함께 생성자 함수
Foo가 호출된다. new Foo는 new Foo()와 동일하다. 즉 인자가 명시되지 않은 경우,
인자 없이 Foo가 호출된다.
3. 생성자 함수에 의해 리턴된 객체는 전체 new 호출 결과가 된다.
만약 생성자 함수가 명시적으로 객체를 리턴하지 않는 경우, 첫 번째 단계에서
생성된 객체가 대신 사용된다. (일반 적으로 생성하는 값을 리턴하지 않는다.
그러나 일반적인 객체 생성을 재정의를 하기 원한다면 그렇게 하도록 선택할 수 있다.
언제든 이전에 정의된 객체에 속성을 추가할 수 있다. 예를 들면 car1.color = "black"구
color속성을 car1에 추가하고 해당 속성에 "black" 이란 값을 할당한다.
그러나, 이것이 다른 객체들에게는 영향을 주지 않는다. 동일한 타입의 모든 객체들에게
새로운 속성을 추가하려면, car 객체 타입의 정의에 이 속성을 추가해야한다.
Function.prototype 속성을 사용하여 이전에 정의된 객체 타입에 공유 속성을 추가할 수 있다.
이것은 객체 타입의 인스턴스 하나에만 적용되는 것이 아니라 이 함수로 생성하는 모든 객체와 공유하는 속성을 정의한다.
car타입의 모든 객체에 " original color"값을 갖는 color 속성을 추가한다.
그리고 car1 객체 인스턴스에세먼 이 값을 문자열"black"으로 덮어쓴다.

※ sort 종류 
입력 : 외부에서 제공되는 자료가 0개 이상 존재한다.
출력 : 적어도 2개 이상의 서로 다른 결과를 내어야 한다. ( 즉 모든 입력에 하나의  출력이 나오면 안된다.)
명확성 : 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.
유한성(종결 성) : 유한 번의 명령어를 수행 후 ( 유한 시간 내 )에 종료한다.
효율성 : 모든 과정은 명백하게 실행 가능 ( 검증 가능) 한 것이어야 한다. 
시간 복잡도 
- 실제 시간을 측정하기엔 개발 환경에 따라 차이가 날 수 있기 때문에 입력 자료 크기 N에 비례한 수행 시간을 통해 구합니다.
- O(1) : 입력 자료의 수에 관계없이 일정한 실행 시간을 갖는 알고리즘
- O(log N) : 입력 자료의 크기가 N일 경우 log2N 번만큼의 수행 시간을 가진다.
- O(N) : 입력 자료의 크기가 N일 경우 N번캄음의 수행 시간을 가진다.
- O(N log N) : 입력 자료의 크기가 N일 경우 N*(log2N)번만큼의 수행 시간을 가진다.
- O(N2) : 입력 자료의 크기가 N일 경우 N2번만큼의 수행 시간을 가진다.
- O(2n) : 입력 자료의 크기가 N일 경우 2N번만큼의 수행 시간을 가진다.
- O(n!) : 입력 자료의 크기가 N일 경우 n*(n-1)*(n-2)...*1(n!)번만큼의 수행 시간을 가진다.
＠ 정령 알고리즘 (버블,선택,삽입) 

 publick class Arrays{
/**
*Sorts the specified array in ascending numerical order.
*
*@param array
* the{@code int} array to be sorted.
*/ 
public static void sort (int[] array){
DualPivotQuicksort.sort(array);
}
＠버블 정렬 : 서로 이웃한 원소들을 비교하며 정렬하는 방식
BubbleSort(A[],n){
// A[0...n]
for last = n down2 {
// last가 2가 될 때까지 for loop n-1번 반복
for i = 1 to ( last -1){
// for loop는 n-1, n-2, n-3 .... 2,1
if (A[i]>A[i+1]) then swap A[i] and A[i+1];
}
}
}
// T(n) = (n-1) + (n-1) + ... + 2+1 n(n-1)/2= O(n2)
＠선택 정렬 : 정렬되지 않은 원소들에 대해 가장 큰 원소를 찾아 가장 뒤의 원소와 교환해나가는 방식.
SelectionSort(A[],n){
// A[0...n]
for last = n down2 {
// last가 2가 될 때까지 for loop n-1번 반복
A[1...last] 중 가장 큰 수 A[k]를 찾는다.;
// 가장 큰 수를 찾기 위해 비교 횟수 : n-1, n-2...1
swap A[k] and A [last];
}
}
// T(n) = (n-1)+(n-2) + ..+2+1=n(n-1)/2 = O(n2) 
＠삽입 정렬 : 아직 정렬되지 않은 임의의 원소를 이미 정렬된 부분의 적절한 위치에 삽입해 가며 정렬하는 방식
InsertionSort(A[],n){
// A[0...n]
for i = 2 to n {
// for loop n-1번 반복
A[1...i]의 적당한 자리에 A[i]를 삽입한다.
// 최악의 경우 i-1번 비교, 최선의 경우 1번 비교 
}
}
// T(n) = (n-1) + (n-2) + ...+ 2+1 = n(n-1)/2 = O(n2) 
＠합병정렬 : 분할 정복법을 사용하는 정렬 알고리즘
- 분할 : 해결하고자 하는 문제를 자은 크기의 동일한 문제들로 분할.
- 정복 : 각각의 작은 문제를 순환적으로 해결.
- 합병 : 작은 문제의 해를 합하여 원래 문제에 대한 해를 구함.
* 최악, 최선, 평균이 항상 O(Niog2N)
MergeSort(A[], p,r){
// A[p...r]
if(p<r){
// 반대일 경우는 item이 1개인 경우 ( 정렬x)
q=(p+r) /2;
// p와 r의 중간지점. 
MergeSort(A,p,q);
// 전반부 분할
MergeSort(A,q+1,r);
// 후반부 분할  
Merge(A,p,q,r);
// 합병
}
}
Merge(A[],p,q,r){
정렬되어 있는 두 배열 A[p..q]와  A[q+1...r]을 합하여 정렬된 하나의 배열 A[p...r]을 만든다.
}
@퀵 정렬 : 분할 정복반을 사용하는 정렬 알고리즘.
- 분할 : 하나의 item을 pivot으로 설정해 pivot 보다 작으면 앞으로, 크면 뒤로 오도록 분할.
- 정복 : 각 부분을 재귀적으로 반복해 정렬.
- 합병 : -
- 최악 : 정렬된 경우 / 처음 item을 pivot으로 설정한 경우 O(N2)
- 최악 : 반대로 정렬된 경우 / 마지막 item을 pivot으로 설정으로 경우 O(N2)
- 평균 : O(Niog2N)
QuickSort(A[],p,r){
// A[p...r]
if(p<r){
// 반대일 경우는 item이 1개인 경우 (정렬 x)
q = Partition(A,p,r);
// 분할 
QuickSort(A,p,q);
// 전반부 정렬
QuickSort(A,q+1,r);
// 후반부 정렬
}
}
Partition(A[],p,r){
A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 
A[r]이 자리한 위치를 return한다.
// pivot 
}
힙 정렬 (Heap sort) : 힙 트리를 이용한 정렬 알고리즘
Heap은 완전 이진트리이면서 Heap property를 만족하는 트리입니다.
1. 주어진 데이터를 Heap으로 만듬
2. Heap에서 최댓값(Root)을 가장 마지막 값과 바꿈
3. Heap의 크기가 1줄어든 것으로 간주
4. Root 노드에 대해서 HEAPIFY 한다.
5. 2~4번 반복
 @ 완전 이진트리 : 마지막 레벨을 제외하면 완전히 꽉 차있고 마지막 레벨에서 가장 
오른쪽에서부터 연속된 몇 개의 노드가 비어있을 수 있음.
- Heap property : 부모는 자식보다 크거나 같다 (max). 부모는 자식보다 작거나 같다(min).
- HEAPIFY : Heap property 만족하게 하기.
@최악, 최선, 평균이 항상 O(Niog2N)
@탐색 알고리즘(순차,이진)
탐색 알고리즘은 크게 순차 탐색, 이진 탐색으로 나눌수 있다.
만약 배열이 정렬되어 있지 않다면 흔히 하는 for loop를 이용해 순차 탐색을 해야 한다.
public int searchValue(int []N, int value) {
int n = N,length;
for (int i = 0; i<n; i++){
if(N[i] == value){
return value;
}
}
return -1;
}

